<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespacetf" kind="namespace" language="C++">
    <compoundname>tf</compoundname>
    <innerclass refid="structtf_1_1IsPod" prot="private">tf::IsPod</innerclass>
    <innerclass refid="classtf_1_1SmallVectorBase" prot="private">tf::SmallVectorBase</innerclass>
    <innerclass refid="structtf_1_1SmallVectorStorage" prot="private">tf::SmallVectorStorage</innerclass>
    <innerclass refid="classtf_1_1SmallVectorTemplateCommon" prot="private">tf::SmallVectorTemplateCommon</innerclass>
    <innerclass refid="classtf_1_1SmallVectorTemplateBase" prot="private">tf::SmallVectorTemplateBase</innerclass>
    <innerclass refid="classtf_1_1SmallVectorTemplateBase_3_01T_00_01true_01_4" prot="private">tf::SmallVectorTemplateBase&lt; T, true &gt;</innerclass>
    <innerclass refid="classtf_1_1SmallVectorImpl" prot="private">tf::SmallVectorImpl</innerclass>
    <innerclass refid="structtf_1_1SmallVectorStorage_3_01T_00_011_01_4" prot="private">tf::SmallVectorStorage&lt; T, 1 &gt;</innerclass>
    <innerclass refid="structtf_1_1SmallVectorStorage_3_01T_00_010_01_4" prot="private">tf::SmallVectorStorage&lt; T, 0 &gt;</innerclass>
    <innerclass refid="classtf_1_1SmallVector" prot="public">tf::SmallVector</innerclass>
    <innerclass refid="classtf_1_1Graph" prot="public">tf::Graph</innerclass>
    <innerclass refid="classtf_1_1Runtime" prot="public">tf::Runtime</innerclass>
    <innerclass refid="structtf_1_1TaskParams" prot="public">tf::TaskParams</innerclass>
    <innerclass refid="structtf_1_1DefaultTaskParams" prot="public">tf::DefaultTaskParams</innerclass>
    <innerclass refid="classtf_1_1Node" prot="private">tf::Node</innerclass>
    <innerclass refid="structtf_1_1NodeDeleter" prot="private">tf::NodeDeleter</innerclass>
    <innerclass refid="classtf_1_1TaskQueue" prot="public">tf::TaskQueue</innerclass>
    <innerclass refid="classtf_1_1FlowBuilder" prot="public">tf::FlowBuilder</innerclass>
    <innerclass refid="classtf_1_1Subflow" prot="public">tf::Subflow</innerclass>
    <innerclass refid="classtf_1_1Worker" prot="public">tf::Worker</innerclass>
    <innerclass refid="classtf_1_1WorkerView" prot="public">tf::WorkerView</innerclass>
    <innerclass refid="classtf_1_1Executor" prot="public">tf::Executor</innerclass>
    <innerclass refid="classtf_1_1Task" prot="public">tf::Task</innerclass>
    <innerclass refid="classtf_1_1TaskView" prot="public">tf::TaskView</innerclass>
    <innerclass refid="classtf_1_1AsyncTask" prot="public">tf::AsyncTask</innerclass>
    <innerclass refid="classtf_1_1Semaphore" prot="public">tf::Semaphore</innerclass>
    <innerclass refid="classtf_1_1Taskflow" prot="public">tf::Taskflow</innerclass>
    <innerclass refid="classtf_1_1Future" prot="public">tf::Future</innerclass>
    <innerclass refid="structtf_1_1Segment" prot="private">tf::Segment</innerclass>
    <innerclass refid="structtf_1_1Timeline" prot="private">tf::Timeline</innerclass>
    <innerclass refid="structtf_1_1ProfileData" prot="private">tf::ProfileData</innerclass>
    <innerclass refid="classtf_1_1ObserverInterface" prot="public">tf::ObserverInterface</innerclass>
    <innerclass refid="classtf_1_1ChromeObserver" prot="public">tf::ChromeObserver</innerclass>
    <innerclass refid="classtf_1_1TFProfObserver" prot="public">tf::TFProfObserver</innerclass>
    <innerclass refid="classtf_1_1TFProfManager" prot="private">tf::TFProfManager</innerclass>
    <innerclass refid="structtf_1_1DefaultClosureWrapper" prot="public">tf::DefaultClosureWrapper</innerclass>
    <innerclass refid="structtf_1_1IsPartitioner" prot="private">tf::IsPartitioner</innerclass>
    <innerclass refid="classtf_1_1PartitionerBase" prot="public">tf::PartitionerBase</innerclass>
    <innerclass refid="classtf_1_1GuidedPartitioner" prot="public">tf::GuidedPartitioner</innerclass>
    <innerclass refid="classtf_1_1DynamicPartitioner" prot="public">tf::DynamicPartitioner</innerclass>
    <innerclass refid="classtf_1_1StaticPartitioner" prot="public">tf::StaticPartitioner</innerclass>
    <innerclass refid="classtf_1_1RandomPartitioner" prot="public">tf::RandomPartitioner</innerclass>
    <innerclass refid="classtf_1_1CriticalSection" prot="public">tf::CriticalSection</innerclass>
    <innerclass refid="classtf_1_1DeferredPipeflow" prot="private">tf::DeferredPipeflow</innerclass>
    <innerclass refid="classtf_1_1Pipeflow" prot="public">tf::Pipeflow</innerclass>
    <innerclass refid="classtf_1_1Pipe" prot="public">tf::Pipe</innerclass>
    <innerclass refid="classtf_1_1Pipeline" prot="public">tf::Pipeline</innerclass>
    <innerclass refid="classtf_1_1ScalablePipeline" prot="public">tf::ScalablePipeline</innerclass>
    <innerclass refid="classtf_1_1DataPipe" prot="public">tf::DataPipe</innerclass>
    <innerclass refid="classtf_1_1DataPipeline" prot="public">tf::DataPipeline</innerclass>
    <innerclass refid="classtf_1_1cudaScopedDevice" prot="public">tf::cudaScopedDevice</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory" prot="private">tf::cudaSharedMemory</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01int_01_4" prot="private">tf::cudaSharedMemory&lt; int &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01int_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned int &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01char_01_4" prot="private">tf::cudaSharedMemory&lt; char &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01char_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned char &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01short_01_4" prot="private">tf::cudaSharedMemory&lt; short &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01short_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned short &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01long_01_4" prot="private">tf::cudaSharedMemory&lt; long &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01long_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned long &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01bool_01_4" prot="private">tf::cudaSharedMemory&lt; bool &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01float_01_4" prot="private">tf::cudaSharedMemory&lt; float &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01double_01_4" prot="private">tf::cudaSharedMemory&lt; double &gt;</innerclass>
    <innerclass refid="classtf_1_1cudaDeviceAllocator" prot="public">tf::cudaDeviceAllocator</innerclass>
    <innerclass refid="classtf_1_1cudaUSMAllocator" prot="public">tf::cudaUSMAllocator</innerclass>
    <innerclass refid="classtf_1_1cudaDeviceVector" prot="private">tf::cudaDeviceVector</innerclass>
    <innerclass refid="structtf_1_1cudaStreamCreator" prot="private">tf::cudaStreamCreator</innerclass>
    <innerclass refid="structtf_1_1cudaStreamDeleter" prot="private">tf::cudaStreamDeleter</innerclass>
    <innerclass refid="classtf_1_1cudaStream" prot="public">tf::cudaStream</innerclass>
    <innerclass refid="structtf_1_1cudaEventCreator" prot="private">tf::cudaEventCreator</innerclass>
    <innerclass refid="structtf_1_1cudaEventDeleter" prot="private">tf::cudaEventDeleter</innerclass>
    <innerclass refid="classtf_1_1cudaEvent" prot="public">tf::cudaEvent</innerclass>
    <innerclass refid="classtf_1_1cudaTask" prot="public">tf::cudaTask</innerclass>
    <innerclass refid="classtf_1_1cudaFlow" prot="public">tf::cudaFlow</innerclass>
    <innerclass refid="classtf_1_1cudaFlowOptimizerBase" prot="private">tf::cudaFlowOptimizerBase</innerclass>
    <innerclass refid="classtf_1_1cudaFlowSequentialOptimizer" prot="public">tf::cudaFlowSequentialOptimizer</innerclass>
    <innerclass refid="classtf_1_1cudaFlowLinearOptimizer" prot="public">tf::cudaFlowLinearOptimizer</innerclass>
    <innerclass refid="classtf_1_1cudaFlowRoundRobinOptimizer" prot="public">tf::cudaFlowRoundRobinOptimizer</innerclass>
    <innerclass refid="classtf_1_1cudaFlowCapturer" prot="public">tf::cudaFlowCapturer</innerclass>
    <innerclass refid="classtf_1_1cudaExecutionPolicy" prot="public">tf::cudaExecutionPolicy</innerclass>
    <innernamespace refid="namespacetf_1_1detail">tf::detail</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacetf_1ac9f4add8f716ed323b0bdbbc1d89346f" prot="public" static="no" strong="yes">
        <type>unsigned</type>
        <name>TaskPriority</name>
        <enumvalue id="namespacetf_1ac9f4add8f716ed323b0bdbbc1d89346fab89de3b4b81c4facfac906edf29aec8c" prot="public">
          <name>HIGH</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>value of the highest priority (i.e., 0) <linebreak/>
 </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1ac9f4add8f716ed323b0bdbbc1d89346fa1e23852820b9154316c7c06e2b7ba051" prot="public">
          <name>NORMAL</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>value of the normal priority (i.e., 1) <linebreak/>
 </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1ac9f4add8f716ed323b0bdbbc1d89346fa41bc94cbd8eebea13ce0491b2ac11b88" prot="public">
          <name>LOW</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>value of the lowest priority (i.e., 2) </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1ac9f4add8f716ed323b0bdbbc1d89346fa26a4b44a837bf97b972628509912b4a5" prot="public">
          <name>MAX</name>
          <initializer>= 3</initializer>
          <briefdescription>
<para>conventional value for iterating priority values </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all task priority values </para>
        </briefdescription>
        <detaileddescription>
<para>A priority is an enumerated value of type <computeroutput>unsigned</computeroutput>. Currently, Taskflow defines three priority levels, <computeroutput>HIGH</computeroutput>, <computeroutput>NORMAL</computeroutput>, and <computeroutput>LOW</computeroutput>, starting from 0, 1, to 2. That is, the lower the value, the higher the priority. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/tsq.hpp" line="29" column="1" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/tsq.hpp" bodystart="29" bodyend="38"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1a1355048578785a80414707ff308b395a" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>TaskType</name>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" prot="public">
          <name>PLACEHOLDER</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>placeholder task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" prot="public">
          <name>STATIC</name>
          <briefdescription>
<para>static task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa46be697979903d784a70aeec45eb14ad" prot="public">
          <name>SUBFLOW</name>
          <briefdescription>
<para>dynamic (subflow) task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" prot="public">
          <name>CONDITION</name>
          <briefdescription>
<para>condition task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" prot="public">
          <name>MODULE</name>
          <briefdescription>
<para>module task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" prot="public">
          <name>ASYNC</name>
          <briefdescription>
<para>asynchronous task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa0db45d2a4141101bdfe48e3314cfbca3" prot="public">
          <name>UNDEFINED</name>
          <briefdescription>
<para>undefined task type (for internal use only) </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all task types </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" line="21" column="1" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" bodystart="21" bodyend="36"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435d" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>ObserverType</name>
        <enumvalue id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435dac19bf39d8838d00eddb556775fa8acce" prot="public">
          <name>TFPROF</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435da37960509766262569d504f02a0ee986d" prot="public">
          <name>CHROME</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435da0db45d2a4141101bdfe48e3314cfbca3" prot="public">
          <name>UNDEFINED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all observer types </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/observer.hpp" line="1026" column="1" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/observer.hpp" bodystart="1026" bodyend="1030"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1a32d51425fa23cd0dc3518c16cf3bb6c0" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>PartitionerType</name>
        <enumvalue id="namespacetf_1a32d51425fa23cd0dc3518c16cf3bb6c0afe6f99ef1ec99efbdc19a9786cf1facc" prot="public">
          <name>STATIC</name>
          <briefdescription>
<para>static partitioner type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a32d51425fa23cd0dc3518c16cf3bb6c0a0fcc90da4811c877ba9f9c12f7d60bc9" prot="public">
          <name>DYNAMIC</name>
          <briefdescription>
<para>dynamic partitioner type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all partitioner types </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/algorithm/partitioner.hpp" line="19" column="1" bodyfile="/home/thuang295/Code/taskflow/taskflow/algorithm/partitioner.hpp" bodystart="19" bodyend="24"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>PipeType</name>
        <enumvalue id="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564adf13a99b035d6f0bce4f44ab18eec8eb" prot="public">
          <name>PARALLEL</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>parallel type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" prot="public">
          <name>SERIAL</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>serial type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all pipe types </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/algorithm/pipeline.hpp" line="197" column="1" bodyfile="/home/thuang295/Code/taskflow/taskflow/algorithm/pipeline.hpp" bodystart="197" bodyend="202"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132e" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>cudaTaskType</name>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132eaba2b45bdc11e2a4a6e86aab2ac693cbb" prot="public">
          <name>EMPTY</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>empty task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132eab9361011891280a44d85b967739cc6a5" prot="public">
          <name>HOST</name>
          <briefdescription>
<para>host task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132ea41d4dbfd78ceea21abb0ecb03c3cc921" prot="public">
          <name>MEMSET</name>
          <briefdescription>
<para>memory set task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132eac5d10cc70cce96265c445f14e7f5aba4" prot="public">
          <name>MEMCPY</name>
          <briefdescription>
<para>memory copy task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132ea35c10219c45ccfb5b07444fd7e17214c" prot="public">
          <name>KERNEL</name>
          <briefdescription>
<para>memory copy task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132ea46be697979903d784a70aeec45eb14ad" prot="public">
          <name>SUBFLOW</name>
          <briefdescription>
<para>subflow (child graph) task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132eab72f08e0732365cac9599b5c42157bf9" prot="public">
          <name>CAPTURE</name>
          <briefdescription>
<para>capture task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132ea0db45d2a4141101bdfe48e3314cfbca3" prot="public">
          <name>UNDEFINED</name>
          <briefdescription>
<para>undefined task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all cudaTask types </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_task.hpp" line="21" column="1" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_task.hpp" bodystart="21" bodyend="38"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacetf_1a8cff4bbd797dde4dfab096c3cc657833" prot="public" static="no">
        <type><ref refid="cpp/chrono/time_point" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::chrono::time_point</ref>&lt; <ref refid="cpp/chrono/steady_clock" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::chrono::steady_clock</ref> &gt;</type>
        <definition>using tf::observer_stamp_t = typedef std::chrono::time_point&lt;std::chrono::steady_clock&gt;</definition>
        <argsstring></argsstring>
        <name>observer_stamp_t</name>
        <briefdescription>
<para>default time point type of observers </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/observer.hpp" line="20" column="1" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/observer.hpp" bodystart="20" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetf_1a66b72776c788898aee9e132b0ea9b405" prot="public" static="no">
        <type><ref refid="classtf_1_1GuidedPartitioner" kindref="compound">GuidedPartitioner</ref>&lt;&gt;</type>
        <definition>using tf::DefaultPartitioner = typedef GuidedPartitioner&lt;&gt;</definition>
        <argsstring></argsstring>
        <name>DefaultPartitioner</name>
        <briefdescription>
<para>default partitioner set to <ref refid="classtf_1_1GuidedPartitioner" kindref="compound">tf::GuidedPartitioner</ref> </para>
        </briefdescription>
        <detaileddescription>
<para>Guided partitioner can achieve decent performance for most parallel algorithms, especially for those with irregular and unbalanced workload per iteration. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/algorithm/partitioner.hpp" line="796" column="1" bodyfile="/home/thuang295/Code/taskflow/taskflow/algorithm/partitioner.hpp" bodystart="796" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetf_1a0e267ab3e1baeb1962f3b3a374de9553" prot="public" static="no">
        <type><ref refid="classtf_1_1cudaExecutionPolicy" kindref="compound">cudaExecutionPolicy</ref>&lt; 512, 7 &gt;</type>
        <definition>using tf::cudaDefaultExecutionPolicy = typedef cudaExecutionPolicy&lt;512, 7&gt;</definition>
        <argsstring></argsstring>
        <name>cudaDefaultExecutionPolicy</name>
        <briefdescription>
<para>default execution policy </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_execution_policy.hpp" line="150" column="1" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_execution_policy.hpp" bodystart="150" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacetf_1ad3a41adc2499a9519da3e77dc3e9849c" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_task_params_v</definition>
        <argsstring></argsstring>
        <name>is_task_params_v</name>
        <initializer>=
  std::is_same_v&lt;std::decay_t&lt;P&gt;, <ref refid="structtf_1_1TaskParams" kindref="compound">TaskParams</ref>&gt; ||
  std::is_same_v&lt;std::decay_t&lt;P&gt;, <ref refid="structtf_1_1DefaultTaskParams" kindref="compound">DefaultTaskParams</ref>&gt; ||
  std::is_constructible_v&lt;<ref refid="cpp/string/basic_string" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::string</ref>, P&gt;</initializer>
        <briefdescription>
<para>determines if the given type is a task parameter type </para>
        </briefdescription>
        <detaileddescription>
<para><ref refid="classtf_1_1Task" kindref="compound">Task</ref> parameters can be specified in one of the following types:<itemizedlist>
<listitem><para><ref refid="structtf_1_1TaskParams" kindref="compound">tf::TaskParams</ref>: assign the struct of defined parameters</para>
</listitem><listitem><para><ref refid="structtf_1_1DefaultTaskParams" kindref="compound">tf::DefaultTaskParams</ref>: assign nothing</para>
</listitem><listitem><para><ref refid="cpp/string/basic_string" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::string</ref>: assign a name to the task </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/graph.hpp" line="564" column="16" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/graph.hpp" bodystart="564" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a6e7c9182ac3f60e339a7497c16633d28" prot="private" static="no" mutable="no">
        <type>ObjectPool&lt; Node &gt;</type>
        <definition>ObjectPool&lt;Node&gt; tf::node_pool</definition>
        <argsstring></argsstring>
        <name>node_pool</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/graph.hpp" line="773" column="19" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/graph.hpp" bodystart="773" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a872cf263ab68abc7c3180710fb792528" prot="private" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array</ref>&lt; <ref refid="namespacetf_1a1355048578785a80414707ff308b395a" kindref="member">TaskType</ref>, 6 &gt;</type>
        <definition>constexpr std::array&lt;TaskType, 6&gt; tf::TASK_TYPES</definition>
        <argsstring></argsstring>
        <name>TASK_TYPES</name>
        <initializer>= {
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" kindref="member">TaskType::PLACEHOLDER</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" kindref="member">TaskType::STATIC</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa46be697979903d784a70aeec45eb14ad" kindref="member">TaskType::SUBFLOW</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" kindref="member">TaskType::CONDITION</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" kindref="member">TaskType::MODULE</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" kindref="member">TaskType::ASYNC</ref>,
}</initializer>
        <briefdescription>
<para>array of all task types (used for iterating task types) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" line="42" column="29" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" bodystart="42" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1aefeb96086f4a99f0e58a0f321012a52c" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_subflow_task_v</definition>
        <argsstring></argsstring>
        <name>is_subflow_task_v</name>
        <initializer>= 
  std::is_invocable_r_v&lt;void, C, <ref refid="classtf_1_1Subflow" kindref="compound">Subflow</ref>&amp;&gt; &amp;&amp;
  !std::is_invocable_r_v&lt;void, C, <ref refid="classtf_1_1Runtime" kindref="compound">Runtime</ref>&amp;&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a dynamic task </para>
        </briefdescription>
        <detaileddescription>
<para>A dynamic task is a callable object constructible from std::function&lt;void(Subflow&amp;)&gt;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" line="92" column="16" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" bodystart="92" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a00ca2fc2de0e679a7d9b8039340343df" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_condition_task_v</definition>
        <argsstring></argsstring>
        <name>is_condition_task_v</name>
        <initializer>= 
  (std::is_invocable_r_v&lt;int, C&gt; || std::is_invocable_r_v&lt;int, C, <ref refid="classtf_1_1Runtime" kindref="compound">Runtime</ref>&amp;&gt;) &amp;&amp;
  !<ref refid="namespacetf_1aefeb96086f4a99f0e58a0f321012a52c" kindref="member">is_subflow_task_v</ref>&lt;C&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a condition task </para>
        </briefdescription>
        <detaileddescription>
<para>A condition task is a callable object constructible from std::function&lt;int()&gt; or std::function&lt;int(tf::Runtime&amp;)&gt;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" line="103" column="16" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" bodystart="103" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a78c40dc8776735b0f2c27cd446481aff" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_multi_condition_task_v</definition>
        <argsstring></argsstring>
        <name>is_multi_condition_task_v</name>
        <initializer>=
  (std::is_invocable_r_v&lt;<ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt;int&gt;, C&gt; ||
  std::is_invocable_r_v&lt;<ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt;int&gt;, C, <ref refid="classtf_1_1Runtime" kindref="compound">Runtime</ref>&amp;&gt;) &amp;&amp;
  !<ref refid="namespacetf_1aefeb96086f4a99f0e58a0f321012a52c" kindref="member">is_subflow_task_v</ref>&lt;C&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a multi-condition task </para>
        </briefdescription>
        <detaileddescription>
<para>A multi-condition task is a callable object constructible from <ref refid="cpp/utility/functional/function" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::function</ref>&lt;tf::SmallVector&lt;int&gt;()&gt; or <ref refid="cpp/utility/functional/function" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::function</ref>&lt;tf::SmallVector&lt;int&gt;(tf::Runtime&amp;)&gt;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" line="115" column="16" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" bodystart="115" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a11fc9c98eb3a0d3a9aa55598b1f4d614" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_static_task_v</definition>
        <argsstring></argsstring>
        <name>is_static_task_v</name>
        <initializer>=
  (std::is_invocable_r_v&lt;void, C&gt; || std::is_invocable_r_v&lt;void, C, <ref refid="classtf_1_1Runtime" kindref="compound">Runtime</ref>&amp;&gt;) &amp;&amp;
  !<ref refid="namespacetf_1a00ca2fc2de0e679a7d9b8039340343df" kindref="member">is_condition_task_v</ref>&lt;C&gt; &amp;&amp;
  !<ref refid="namespacetf_1a78c40dc8776735b0f2c27cd446481aff" kindref="member">is_multi_condition_task_v</ref>&lt;C&gt; &amp;&amp;
  !<ref refid="namespacetf_1aefeb96086f4a99f0e58a0f321012a52c" kindref="member">is_subflow_task_v</ref>&lt;C&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a static task </para>
        </briefdescription>
        <detaileddescription>
<para>A static task is a callable object constructible from std::function&lt;void()&gt; or std::function&lt;void(tf::Runtime&amp;)&gt;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" line="127" column="16" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" bodystart="127" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a73c20705fc54763f195a00b6e626e301" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_partitioner_v</definition>
        <argsstring></argsstring>
        <name>is_partitioner_v</name>
        <initializer>= <ref refid="cpp/types/is_base_of" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::is_base_of</ref>&lt;IsPartitioner, P&gt;::value</initializer>
        <briefdescription>
<para>determines if a type is a partitioner </para>
        </briefdescription>
        <detaileddescription>
<para>A partitioner is a derived type from <ref refid="classtf_1_1PartitionerBase" kindref="compound">tf::PartitionerBase</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/algorithm/partitioner.hpp" line="804" column="23" bodyfile="/home/thuang295/Code/taskflow/taskflow/algorithm/partitioner.hpp" bodystart="804" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacetf_1aea9fe5c87d4439816239b5af6ebeec55" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>unsigned</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>static size_t tf::capacity_in_bytes</definition>
        <argsstring>(const SmallVector&lt; T, N &gt; &amp;X)</argsstring>
        <name>capacity_in_bytes</name>
        <param>
          <type>const <ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt; T, N &gt; &amp;</type>
          <declname>X</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/utility/small_vector.hpp" line="1026" column="22" bodyfile="/home/thuang295/Code/taskflow/taskflow/utility/small_vector.hpp" bodystart="1026" bodyend="1028"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9ca58dc6c666698cc7373eb0262140ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* tf::to_string</definition>
        <argsstring>(TaskType type)</argsstring>
        <name>to_string</name>
        <param>
          <type><ref refid="namespacetf_1a1355048578785a80414707ff308b395a" kindref="member">TaskType</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>convert a task type to a human-readable string </para>
        </briefdescription>
        <detaileddescription>
<para>The name of each task type is the litte-case string of its characters.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" kindref="member">TaskType::PLACEHOLDER</ref><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;placeholder&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" kindref="member">TaskType::STATIC</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;static&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa46be697979903d784a70aeec45eb14ad" kindref="member">TaskType::SUBFLOW</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;subflow&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" kindref="member">TaskType::CONDITION</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;condition&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" kindref="member">TaskType::MODULE</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;module&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" kindref="member">TaskType::ASYNC</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;async&quot;</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" line="65" column="19" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" bodystart="65" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ad216aea4d0f648e149e47374ad015b1f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
        <definition>std::ostream&amp; tf::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Task &amp;task)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classtf_1_1Task" kindref="compound">Task</ref> &amp;</type>
          <declname>task</declname>
        </param>
        <briefdescription>
<para>overload of ostream inserter operator for <ref refid="classtf_1_1Task" kindref="compound">Task</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" line="605" column="8" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/task.hpp" bodystart="605" bodyend="608"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aa3fc0699b2c2b8f2f76bb39f91be1acb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* tf::to_string</definition>
        <argsstring>(ObserverType type)</argsstring>
        <name>to_string</name>
        <param>
          <type><ref refid="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435d" kindref="member">ObserverType</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>convert an observer type to a human-readable string </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/core/observer.hpp" line="1035" column="19" bodyfile="/home/thuang295/Code/taskflow/taskflow/core/observer.hpp" bodystart="1035" bodyend="1041"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8975fa5762088789adb0b60f38208309" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Input</type>
          </param>
          <param>
            <type>typename Output</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::make_data_pipe</definition>
        <argsstring>(PipeType d, C &amp;&amp;callable)</argsstring>
        <name>make_data_pipe</name>
        <param>
          <type><ref refid="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564" kindref="member">PipeType</ref></type>
          <declname>d</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>function to construct a data pipe (<ref refid="classtf_1_1DataPipe" kindref="compound">tf::DataPipe</ref>) </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Input</parametername>
</parameternamelist>
<parameterdescription>
<para>input data type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Output</parametername>
</parameternamelist>
<parameterdescription>
<para>output data type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<ref refid="namespacetf_1a8975fa5762088789adb0b60f38208309" kindref="member">tf::make_data_pipe</ref> is a helper function to create a data pipe (<ref refid="classtf_1_1DataPipe" kindref="compound">tf::DataPipe</ref>) in a data-parallel pipeline (<ref refid="classtf_1_1DataPipeline" kindref="compound">tf::DataPipeline</ref>). The first argument specifies the direction of the data pipe, either <ref refid="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" kindref="member">tf::PipeType::SERIAL</ref> or <ref refid="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564adf13a99b035d6f0bce4f44ab18eec8eb" kindref="member">tf::PipeType::PARALLEL</ref>, and the second argument is a callable to invoke by the pipeline scheduler. Input and output data types are specified via template parameters, which will always be decayed by the library to its original form for storage purpose. The callable must take the input data type in its first argument and returns a value of the output data type.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">tf::make_data_pipe&lt;int,<sp/>std::string&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" kindref="member">tf::PipeType::SERIAL</ref>,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&amp;<sp/>input)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespacetf_1a9ca58dc6c666698cc7373eb0262140ef" kindref="member">std::to_string</ref>(input<sp/>+<sp/>100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para>The callable can additionally take a reference of <ref refid="classtf_1_1Pipeflow" kindref="compound">tf::Pipeflow</ref>, which allows you to query the runtime information of a stage task, such as its line number and token number.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">tf::make_data_pipe&lt;int,<sp/>std::string&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" kindref="member">tf::PipeType::SERIAL</ref>,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&amp;<sp/>input,<sp/><ref refid="classtf_1_1Pipeflow" kindref="compound">tf::Pipeflow</ref>&amp;<sp/>pf)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;token=%lu,<sp/>line=%lu\n&quot;</highlight><highlight class="normal">,<sp/>pf.<ref refid="classtf_1_1Pipeflow_1a295e5d884665c076f4ef5d78139f7c51" kindref="member">token</ref>(),<sp/>pf.<ref refid="classtf_1_1Pipeflow_1afee054e6a99965d4b3e36ff903227e6c" kindref="member">line</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespacetf_1a9ca58dc6c666698cc7373eb0262140ef" kindref="member">std::to_string</ref>(input<sp/>+<sp/>100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/algorithm/data_pipeline.hpp" line="171" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/algorithm/data_pipeline.hpp" bodystart="171" bodyend="173"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abffa70155a5f160b7ceb86ee52ab2136" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_num_devices</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_num_devices</name>
        <briefdescription>
<para>queries the number of available devices </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="15" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="15" bodyend="19"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a235f5a9ce203d538eec1f4114221d473" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_device</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_device</name>
        <briefdescription>
<para>gets the current device associated with the caller thread </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="24" column="12" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="24" bodyend="28"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ade2938289fa49aafc9b2b7b090deaa22" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_set_device</definition>
        <argsstring>(int id)</argsstring>
        <name>cuda_set_device</name>
        <param>
          <type>int</type>
          <declname>id</declname>
        </param>
        <briefdescription>
<para>switches to a given device context </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="33" column="13" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="33" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a403b679694f4c85c857163b47e84d566" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_get_device_property</definition>
        <argsstring>(int i, cudaDeviceProp &amp;p)</argsstring>
        <name>cuda_get_device_property</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>cudaDeviceProp &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>obtains the device property </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="40" column="13" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="40" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a0e82b8a929e12349240276e34ec9f8c8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>cudaDeviceProp</type>
        <definition>cudaDeviceProp tf::cuda_get_device_property</definition>
        <argsstring>(int i)</argsstring>
        <name>cuda_get_device_property</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>obtains the device property </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="49" column="23" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="49" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aff8073c78daa741df76b530a0e602287" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_dump_device_property</definition>
        <argsstring>(std::ostream &amp;os, const cudaDeviceProp &amp;p)</argsstring>
        <name>cuda_dump_device_property</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const cudaDeviceProp &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>dumps the device property </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="60" column="13" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="60" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abf813f7ac4249d1b752d1b724f970deb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_threads_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_threads_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum threads per block on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="102" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="102" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1af8184bb128c446fe383315f3dc15acf6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_x_dim_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_x_dim_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum x-dimension per block on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="114" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="114" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9aba5f29135b9da29015c2a367ab1d70" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_y_dim_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_y_dim_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum y-dimension per block on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="126" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="126" bodyend="133"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a5580f59e633625b2f344bbf477d17c2f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_z_dim_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_z_dim_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum z-dimension per block on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="138" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="138" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a597579c8a9ab31244418e30a5aa74491" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_x_dim_per_grid</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_x_dim_per_grid</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum x-dimension per grid on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="150" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="150" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a91d5c1609a7542949dd56d08b7c4c645" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_y_dim_per_grid</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_y_dim_per_grid</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum y-dimension per grid on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="162" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="162" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a0373e32a20c7fc90c4f0461ee41bb918" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_z_dim_per_grid</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_z_dim_per_grid</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum z-dimension per grid on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="174" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="174" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aeca46ac171c4941a75aafddfe7546bfa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_shm_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_shm_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum shared memory size in bytes per block on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="186" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="186" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aea1b2af1073496f047d6fb9984cff4f1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_warp_size</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_warp_size</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the warp size on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="198" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="198" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a1fb03793a6b8705026b80ef87599d4d5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_device_compute_capability_major</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_compute_capability_major</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the major number of compute capability of a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="210" column="12" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="210" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a71f5177665f4f7e18984ccc57d625602" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_device_compute_capability_minor</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_compute_capability_minor</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the minor number of compute capability of a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="222" column="12" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="222" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ad389294b4d1c14219d8d098f796e27c5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tf::cuda_get_device_unified_addressing</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_unified_addressing</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries if the device supports unified addressing </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="234" column="13" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="234" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a43ac57f0eca3aa83c04bec3c4da9ab82" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_driver_version</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_driver_version</name>
        <briefdescription>
<para>queries the latest CUDA version (1000 * major + 10 * minor) supported by the driver </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="250" column="12" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="250" bodyend="257"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a31258ad089c6f847c8cd636cd72d6949" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_runtime_version</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_runtime_version</name>
        <briefdescription>
<para>queries the CUDA <ref refid="classtf_1_1Runtime" kindref="compound">Runtime</ref> version (1000 * major + 10 * minor) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="262" column="12" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="262" bodyend="268"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a1effcf929b7e488925f9e12d74c8c62b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_free_mem</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_free_mem</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the free memory (expensive call) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="19" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="19" bodyend="26"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a58bbc8d5d955582d6b5f7fdac51d010b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_total_mem</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_total_mem</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the total available memory (expensive call) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="31" column="15" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="31" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a6f04fd3168c45eeb2dffb223e5c81e45" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* tf::cuda_malloc_device</definition>
        <argsstring>(size_t N, int d)</argsstring>
        <name>cuda_malloc_device</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>allocates memory on the given device for holding <computeroutput>N</computeroutput> elements of type <computeroutput>T</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>The function calls <computeroutput>cudaMalloc</computeroutput> to allocate <computeroutput>N*sizeof(T)</computeroutput> bytes of memory on the given device <computeroutput>d</computeroutput> and returns a pointer to the starting address of the device memory. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="48" column="3" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="48" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ab9b68b8f4336f13b190d573969cb1cf7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* tf::cuda_malloc_device</definition>
        <argsstring>(size_t N)</argsstring>
        <name>cuda_malloc_device</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>allocates memory on the current device associated with the caller </para>
        </briefdescription>
        <detaileddescription>
<para>The function calls malloc_device from the current device associated with the caller. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="65" column="3" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="65" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8eed05685b030fc44703213a4ef86f11" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* tf::cuda_malloc_shared</definition>
        <argsstring>(size_t N)</argsstring>
        <name>cuda_malloc_shared</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>allocates shared memory for holding <computeroutput>N</computeroutput> elements of type <computeroutput>T</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>The function calls <computeroutput>cudaMallocManaged</computeroutput> to allocate <computeroutput>N*sizeof(T)</computeroutput> bytes of memory and returns a pointer to the starting address of the shared memory. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="81" column="3" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="81" bodyend="88"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ac7a8fe7456b888d6072ba94783c5003c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_free</definition>
        <argsstring>(T *ptr, int d)</argsstring>
        <name>cuda_free</name>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>frees memory on the GPU device </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>device pointer to memory to free </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d</parametername>
</parameternamelist>
<parameterdescription>
<para>device context identifier</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This methods call <computeroutput>cudaFree</computeroutput> to free the memory space pointed to by <computeroutput>ptr</computeroutput> using the given device context. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="101" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="101" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ae174a3a49b91ef21554dac16806f0d72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_free</definition>
        <argsstring>(T *ptr)</argsstring>
        <name>cuda_free</name>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>frees memory on the GPU device </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>device pointer to memory to free</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This methods call <computeroutput>cudaFree</computeroutput> to free the memory space pointed to by <computeroutput>ptr</computeroutput> using the current device context of the caller. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="116" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="116" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aa4266474b921f8ed7d9ec8071fded2a4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_memcpy_async</definition>
        <argsstring>(cudaStream_t stream, void *dst, const void *src, size_t count)</argsstring>
        <name>cuda_memcpy_async</name>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>copies data between host and device asynchronously through a stream </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>stream identifier </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>destination memory address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>source memory address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>size in bytes to copy</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The method calls <computeroutput>cudaMemcpyAsync</computeroutput> with the given <computeroutput>stream</computeroutput> using <computeroutput>cudaMemcpyDefault</computeroutput> to infer the memory space of the source and the destination pointers. The memory areas may not overlap. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="132" column="13" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="132" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a6615554d2954e895755411ee444d9760" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_memset_async</definition>
        <argsstring>(cudaStream_t stream, void *devPtr, int value, size_t count)</argsstring>
        <name>cuda_memset_async</name>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>devPtr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>value</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>initializes or sets GPU memory to the given value byte by byte </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>stream identifier </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>devPtr</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to GPU mempry </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>value to set for each byte of the specified memory </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>size in bytes to set</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The method calls <computeroutput>cudaMemsetAsync</computeroutput> with the given <computeroutput>stream</computeroutput> to fill the first <computeroutput>count</computeroutput> bytes of the memory area pointed to by <computeroutput>devPtr</computeroutput> with the constant byte value <computeroutput>value</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="153" column="13" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="153" bodyend="160"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1af21fe1eaf680dbddc0503ef5d1a9a664" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr const char *</type>
        <definition>constexpr const char* tf::to_string</definition>
        <argsstring>(cudaTaskType type)</argsstring>
        <name>to_string</name>
        <param>
          <type><ref refid="namespacetf_1afebc56ae6d5765010d0dd13a5f04132e" kindref="member">cudaTaskType</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>convert a cuda_task type to a human-readable string </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_task.hpp" line="43" column="22" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_task.hpp" bodystart="43" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9cca69f61d792afb3ad501b703d795c1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
        <definition>std::ostream&amp; tf::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const cudaTask &amp;ct)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> &amp;</type>
          <declname>ct</declname>
        </param>
        <briefdescription>
<para>overload of ostream inserter operator for <ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_task.hpp" line="266" column="8" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/cuda_task.hpp" bodystart="266" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a2ff1cf81426c856fc6db1f6ead47878f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_single_task</definition>
        <argsstring>(P &amp;&amp;p, C c)</argsstring>
        <name>cuda_single_task</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>runs a callable asynchronously using one kernel thread </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>closure type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>closure to run by one kernel thread</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The function launches a single kernel thread to run the given callable through the stream in the execution policy object. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" line="63" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" bodystart="63" bodyend="67"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a7c449cec0b93503b8280d05add35e9f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_for_each</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, C c)</argsstring>
        <name>cuda_for_each</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel iterations over a range of items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to each dereferenced iterator</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function is equivalent to a parallel execution of the following loop on a GPU:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>itr<sp/>=<sp/>first;<sp/>itr<sp/>!=<sp/>last;<sp/>itr++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>c(*itr);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" line="91" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" bodystart="91" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a01ad7ce62fa6f42f2f2fbff3659b7884" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_for_each_index</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, I inc, C c)</argsstring>
        <name>cuda_for_each_index</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>I</type>
          <declname>inc</declname>
        </param>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel iterations over an index-based range of items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input index type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>index to the beginning of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>index to the end of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inc</parametername>
</parameternamelist>
<parameterdescription>
<para>step size between successive iterations </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to each index</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function is equivalent to a parallel execution of the following loop on a GPU:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>step<sp/>is<sp/>positive<sp/>[first,<sp/>last)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&lt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>c(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>step<sp/>is<sp/>negative<sp/>[first,<sp/>last)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&gt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>c(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" line="136" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" bodystart="136" bodyend="149"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3075c7a1f4d08fefefb415b0e2ac58fb" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void tf::cuda_single_task</definition>
        <argsstring>(C callable)</argsstring>
        <name>cuda_single_task</name>
        <param>
          <type>C</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" line="157" column="17" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" bodystart="157" bodyend="159"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3ed764530620a419e3400e1f9ab6c956" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, O output, C op)</argsstring>
        <name>cuda_transform</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel transforms over a range of items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to transform each item</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*output++<sp/>=<sp/>op(*first++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/transform.hpp" line="86" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/transform.hpp" bodystart="86" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abdcb5b755f7ace2aa452541d5bf93b5f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I1</type>
          </param>
          <param>
            <type>typename I2</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform</definition>
        <argsstring>(P &amp;&amp;p, I1 first1, I1 last1, I2 first2, O output, C op)</argsstring>
        <name>cuda_transform</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>I1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>I2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel transforms over two ranges of items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I1</parametername>
</parameternamelist>
<parameterdescription>
<para>first input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I2</parametername>
</parameternamelist>
<parameterdescription>
<para>second input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to transform each pair of items</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first1<sp/>!=<sp/>last1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*output++<sp/>=<sp/>op(*first1++,<sp/>*first2++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/transform.hpp" line="127" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/transform.hpp" bodystart="127" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8a872d2a0ac73a676713cb5be5aa688c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_reduce</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, T *res, O op, void *buf)</argsstring>
        <name>cuda_reduce</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>res</declname>
        </param>
        <param>
          <type>O</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel reduction over a range of items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the result </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to reduce elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result<sp/>=<sp/>op(*result,<sp/>*first++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" line="253" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" bodystart="253" bodyend="261"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a492e8410db032a0273a99dd905486161" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_uninitialized_reduce</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, T *res, O op, void *buf)</argsstring>
        <name>cuda_uninitialized_reduce</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>res</declname>
        </param>
        <param>
          <type>O</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel reduction over a range of items without an initial value </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the result </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to reduce elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">*result<sp/>=<sp/>*first++;<sp/><sp/></highlight><highlight class="comment">//<sp/>no<sp/>initial<sp/>values<sp/>partitipcate<sp/>in<sp/>the<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result<sp/>=<sp/>op(*result,<sp/>*first++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" line="294" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" bodystart="294" bodyend="302"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a4463d06240d608bc31d8b3546a851e4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform_reduce</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, T *res, O bop, U uop, void *buf)</argsstring>
        <name>cuda_transform_reduce</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>res</declname>
        </param>
        <param>
          <type>O</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>U</type>
          <declname>uop</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel reduction over a range of transformed items without an initial value </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the result </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to reduce elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to transform elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result<sp/>=<sp/>bop(*result,<sp/>uop(*first++));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" line="335" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" bodystart="335" bodyend="352"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aa451668b7a0a3abf385cf2abebed8962" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_uninitialized_transform_reduce</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, T *res, O bop, U uop, void *buf)</argsstring>
        <name>cuda_uninitialized_transform_reduce</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>res</declname>
        </param>
        <param>
          <type>O</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>U</type>
          <declname>uop</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel reduction over a range of transformed items with an initial value </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the result </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to reduce elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to transform elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">*result<sp/>=<sp/>uop(*first++);<sp/><sp/></highlight><highlight class="comment">//<sp/>no<sp/>initial<sp/>values<sp/>partitipcate<sp/>in<sp/>the<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result<sp/>=<sp/>bop(*result,<sp/>uop(*first++));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" line="387" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" bodystart="387" bodyend="401"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a2e1b44c84a09e0a8495a611cb9a7ea40" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_inclusive_scan</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, O output, C op, void *buf)</argsstring>
        <name>cuda_inclusive_scan</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous inclusive scan over a range of items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to scan </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" line="357" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" bodystart="357" bodyend="371"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1afa4aa760ddb6efbda1b9bab505ad5baf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform_inclusive_scan</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, O output, C bop, U uop, void *buf)</argsstring>
        <name>cuda_transform_inclusive_scan</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>U</type>
          <declname>uop</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous inclusive scan over a range of transformed items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to scan </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to transform each item before scan </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" line="392" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" bodystart="392" bodyend="410"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aeb391c40120844318fd715b8c3a716bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_exclusive_scan</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, O output, C op, void *buf)</argsstring>
        <name>cuda_exclusive_scan</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous exclusive scan over a range of items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to scan </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" line="429" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" bodystart="429" bodyend="443"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a2e739895c1c73538967af060ca714366" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform_exclusive_scan</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, O output, C bop, U uop, void *buf)</argsstring>
        <name>cuda_transform_exclusive_scan</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>U</type>
          <declname>uop</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous exclusive scan over a range of items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to scan </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to transform each item before scan </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" line="464" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" bodystart="464" bodyend="482"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aa84d4c68d2cbe9f6efc4a1eb1a115458" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename a_keys_it</type>
          </param>
          <param>
            <type>typename a_vals_it</type>
          </param>
          <param>
            <type>typename b_keys_it</type>
          </param>
          <param>
            <type>typename b_vals_it</type>
          </param>
          <param>
            <type>typename c_keys_it</type>
          </param>
          <param>
            <type>typename c_vals_it</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_merge_by_key</definition>
        <argsstring>(P &amp;&amp;p, a_keys_it a_keys_first, a_keys_it a_keys_last, a_vals_it a_vals_first, b_keys_it b_keys_first, b_keys_it b_keys_last, b_vals_it b_vals_first, c_keys_it c_keys_first, c_vals_it c_vals_first, C comp, void *buf)</argsstring>
        <name>cuda_merge_by_key</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>a_keys_it</type>
          <declname>a_keys_first</declname>
        </param>
        <param>
          <type>a_keys_it</type>
          <declname>a_keys_last</declname>
        </param>
        <param>
          <type>a_vals_it</type>
          <declname>a_vals_first</declname>
        </param>
        <param>
          <type>b_keys_it</type>
          <declname>b_keys_first</declname>
        </param>
        <param>
          <type>b_keys_it</type>
          <declname>b_keys_last</declname>
        </param>
        <param>
          <type>b_vals_it</type>
          <declname>b_vals_first</declname>
        </param>
        <param>
          <type>c_keys_it</type>
          <declname>c_keys_first</declname>
        </param>
        <param>
          <type>c_vals_it</type>
          <declname>c_vals_first</declname>
        </param>
        <param>
          <type>C</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous key-value merge over a range of keys and values </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>first key iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_vals_it</parametername>
</parameternamelist>
<parameterdescription>
<para>first value iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>second key iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_vals_it</parametername>
</parameternamelist>
<parameterdescription>
<para>second value iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>output key iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_vals_it</parametername>
</parameternamelist>
<parameterdescription>
<para>output value iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_vals_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first value range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the second key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_vals_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second value range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_vals_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output value range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Performs a key-value merge that copies elements from <computeroutput>[a_keys_first, a_keys_last)</computeroutput> and <computeroutput>[b_keys_first, b_keys_last)</computeroutput> into a single range, <computeroutput>[c_keys_first, c_keys_last + (a_keys_last - a_keys_first) + (b_keys_last - b_keys_first))</computeroutput> such that the resulting range is in ascending key order.</para>
<para>At the same time, the merge copies elements from the two associated ranges <computeroutput>[a_vals_first + (a_keys_last - a_keys_first))</computeroutput> and <computeroutput>[b_vals_first + (b_keys_last - b_keys_first))</computeroutput> into a single range, <computeroutput>[c_vals_first, c_vals_first + (a_keys_last - a_keys_first) + (b_keys_last - b_keys_first))</computeroutput> such that the resulting range is in ascending order implied by each input element&apos;s associated key.</para>
<para>For example, assume:<itemizedlist>
<listitem><para><computeroutput>a_keys</computeroutput> = {1, 8};</para>
</listitem><listitem><para><computeroutput>a_vals</computeroutput> = {2, 1};</para>
</listitem><listitem><para><computeroutput>b_keys</computeroutput> = {3, 7};</para>
</listitem><listitem><para><computeroutput>b_vals</computeroutput> = {3, 4};</para>
</listitem></itemizedlist>
</para>
<para>After the merge, we have:<itemizedlist>
<listitem><para><computeroutput>c_keys</computeroutput> = {1, 3, 7, 8}</para>
</listitem><listitem><para><computeroutput>c_vals</computeroutput> = {2, 3, 4, 1} </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/merge.hpp" line="515" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/merge.hpp" bodystart="515" bodyend="537"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a37ec481149c2f01669353033d75ed72a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename a_keys_it</type>
          </param>
          <param>
            <type>typename b_keys_it</type>
          </param>
          <param>
            <type>typename c_keys_it</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_merge</definition>
        <argsstring>(P &amp;&amp;p, a_keys_it a_keys_first, a_keys_it a_keys_last, b_keys_it b_keys_first, b_keys_it b_keys_last, c_keys_it c_keys_first, C comp, void *buf)</argsstring>
        <name>cuda_merge</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>a_keys_it</type>
          <declname>a_keys_first</declname>
        </param>
        <param>
          <type>a_keys_it</type>
          <declname>a_keys_last</declname>
        </param>
        <param>
          <type>b_keys_it</type>
          <declname>b_keys_first</declname>
        </param>
        <param>
          <type>b_keys_it</type>
          <declname>b_keys_last</declname>
        </param>
        <param>
          <type>c_keys_it</type>
          <declname>c_keys_first</declname>
        </param>
        <param>
          <type>C</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous key-only merge over a range of keys </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>first key iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>second key iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>output key iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the second key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function is equivalent to <ref refid="namespacetf_1aa84d4c68d2cbe9f6efc4a1eb1a115458" kindref="member">tf::cuda_merge_by_key</ref> without values. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/merge.hpp" line="567" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/merge.hpp" bodystart="567" bodyend="582"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9c69906a4dfd1e2d0cd7ed496d29dafd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename K</type>
          </param>
          <param>
            <type>typename V</type>
            <defval>cudaEmpty</defval>
          </param>
        </templateparamlist>
        <type>unsigned</type>
        <definition>unsigned tf::cuda_sort_buffer_size</definition>
        <argsstring>(unsigned count)</argsstring>
        <name>cuda_sort_buffer_size</name>
        <param>
          <type>unsigned</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>queries the buffer size in bytes needed to call sort kernels for the given number of elements </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>K</parametername>
</parameternamelist>
<parameterdescription>
<para>key type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>V</parametername>
</parameternamelist>
<parameterdescription>
<para>value type (default tf::cudaEmpty)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of keys/values to sort</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The function is used to allocate a buffer for calling <ref refid="namespacetf_1a06804cb1598e965febc7bd35fc0fbbb0" kindref="member">tf::cuda_sort</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" line="417" column="10" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" bodystart="417" bodyend="428"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3461b9179221dd7230ce2a0e45156c7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename K_it</type>
          </param>
          <param>
            <type>typename V_it</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_sort_by_key</definition>
        <argsstring>(P &amp;&amp;p, K_it k_first, K_it k_last, V_it v_first, C comp, void *buf)</argsstring>
        <name>cuda_sort_by_key</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>K_it</type>
          <declname>k_first</declname>
        </param>
        <param>
          <type>K_it</type>
          <declname>k_last</declname>
        </param>
        <param>
          <type>V_it</type>
          <declname>v_first</declname>
        </param>
        <param>
          <type>C</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous key-value sort on a range of items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>K_it</parametername>
</parameternamelist>
<parameterdescription>
<para>key iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>V_it</parametername>
</parameternamelist>
<parameterdescription>
<para>value iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the value range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>binary comparator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Sorts key-value elements in <computeroutput>[k_first, k_last)</computeroutput> and <computeroutput>[v_first, v_first + (k_last - k_first))</computeroutput> into ascending key order using the given comparator <computeroutput>comp</computeroutput>. If <computeroutput>i</computeroutput> and <computeroutput>j</computeroutput> are any two valid iterators in <computeroutput>[k_first, k_last)</computeroutput> such that <computeroutput>i</computeroutput> precedes <computeroutput>j</computeroutput>, and <computeroutput>p</computeroutput> and <computeroutput>q</computeroutput> are iterators in <computeroutput>[v_first, v_first + (k_last - k_first))</computeroutput> corresponding to <computeroutput>i</computeroutput> and <computeroutput>j</computeroutput> respectively, then <computeroutput>comp(*j, *i)</computeroutput> evaluates to <computeroutput>false</computeroutput>.</para>
<para>For example, assume:<itemizedlist>
<listitem><para><computeroutput>keys</computeroutput> are <computeroutput>{1, 4, 2, 8, 5, 7}</computeroutput></para>
</listitem><listitem><para><computeroutput>values</computeroutput> are <computeroutput>{&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;}</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>After sort:<itemizedlist>
<listitem><para><computeroutput>keys</computeroutput> are <computeroutput>{1, 2, 4, 5, 7, 8}</computeroutput></para>
</listitem><listitem><para><computeroutput>values</computeroutput> are <computeroutput>{&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;e&apos;, &apos;f&apos;, &apos;d&apos;}</computeroutput> </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" line="467" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" bodystart="467" bodyend="478"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a06804cb1598e965febc7bd35fc0fbbb0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename K_it</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_sort</definition>
        <argsstring>(P &amp;&amp;p, K_it k_first, K_it k_last, C comp, void *buf)</argsstring>
        <name>cuda_sort</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>K_it</type>
          <declname>k_first</declname>
        </param>
        <param>
          <type>K_it</type>
          <declname>k_last</declname>
        </param>
        <param>
          <type>C</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous key-only sort on a range of items </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>K_it</parametername>
</parameternamelist>
<parameterdescription>
<para>key iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the key range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>binary comparator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to <ref refid="namespacetf_1a3461b9179221dd7230ce2a0e45156c7f" kindref="member">tf::cuda_sort_by_key</ref> without values. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" line="501" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" bodystart="501" bodyend="503"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a5f9dabd7c5d0fa5166cf76d9fa5a038e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_find_if</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, unsigned *idx, U op)</argsstring>
        <name>cuda_find_if</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>unsigned *</type>
          <declname>idx</declname>
        </param>
        <param>
          <type>U</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>finds the index of the first element that satisfies the given criteria </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>idx</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the index of the found element </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator which returns <computeroutput>true</computeroutput> for the required element</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The function launches kernels asynchronously to find the index <computeroutput>idx</computeroutput> of the first element in the range <computeroutput>[first, last)</computeroutput> such that <computeroutput>op(*(first+idx))</computeroutput> is true. This is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>idx<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(;<sp/>first<sp/>!=<sp/>last;<sp/>++first,<sp/>++idx)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(p(*first))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>idx;</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/find.hpp" line="181" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/find.hpp" bodystart="181" bodyend="185"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a572c13198191c46765264f8afabe2e9f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_min_element</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, unsigned *idx, O op, void *buf)</argsstring>
        <name>cuda_min_element</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>unsigned *</type>
          <declname>idx</declname>
        </param>
        <param>
          <type>O</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>finds the index of the minimum element in a range </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>idx</parametername>
</parameternamelist>
<parameterdescription>
<para>solution index of the minimum element </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>comparison function object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the buffer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The function launches kernels asynchronously to find the smallest element in the range <computeroutput>[first, last)</computeroutput> using the given comparator <computeroutput>op</computeroutput>. You need to provide a buffer that holds at least tf::cuda_min_element_bufsz bytes for internal use. The function is equivalent to a parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal">(first<sp/>==<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>smallest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(++first;<sp/>first<sp/>!=<sp/>last;<sp/>++first)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(op(*first,<sp/>*smallest))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>smallest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="cpp/iterator/distance" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::distance</ref>(first,<sp/>smallest);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/find.hpp" line="233" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/find.hpp" bodystart="233" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3fc577fd0a8f127770bcf68bc56c073e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_max_element</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, unsigned *idx, O op, void *buf)</argsstring>
        <name>cuda_max_element</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>unsigned *</type>
          <declname>idx</declname>
        </param>
        <param>
          <type>O</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>finds the index of the maximum element in a range </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>idx</parametername>
</parameternamelist>
<parameterdescription>
<para>solution index of the maximum element </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>comparison function object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the buffer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The function launches kernels asynchronously to find the largest element in the range <computeroutput>[first, last)</computeroutput> using the given comparator <computeroutput>op</computeroutput>. You need to provide a buffer that holds at least tf::cuda_max_element_bufsz bytes for internal use. The function is equivalent to a parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal">(first<sp/>==<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>largest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(++first;<sp/>first<sp/>!=<sp/>last;<sp/>++first)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(op(*largest,<sp/>*first))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>largest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="cpp/iterator/distance" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::distance</ref>(first,<sp/>largest);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/find.hpp" line="285" column="6" bodyfile="/home/thuang295/Code/taskflow/taskflow/cuda/algorithm/find.hpp" bodystart="285" bodyend="289"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a30fa078dcf625e9eada5a95af1467588" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr const char *</type>
        <definition>constexpr const char* tf::version</definition>
        <argsstring>()</argsstring>
        <name>version</name>
        <briefdescription>
<para>queries the version information in a string format <computeroutput>major.minor.patch</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>Release notes are available here: <ulink url="https://taskflow.github.io/taskflow/Releases.html">https://taskflow.github.io/taskflow/Releases.html</ulink> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thuang295/Code/taskflow/taskflow/taskflow.hpp" line="59" column="22" bodyfile="/home/thuang295/Code/taskflow/taskflow/taskflow.hpp" bodystart="59" bodyend="61"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>taskflow namespace </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/thuang295/Code/taskflow/taskflow/utility/small_vector.hpp" line="27" column="1"/>
  </compounddef>
</doxygen>
